## WTF is a Runtime?
Software or instruction set that are executed while the program is running and facilitate the execution of code

## Scheduler:
- Go scheduler allows multithreaded go programs to be more efficient and performant. Go scheduler mimics the OS scheduler
- layout and setup of the hardware they run on, multiple processors and cores, "LINK:CPU caches and NUMA"
- program is a series of machine instructions that need to be executed one after the other sequentially
- Thread: account for and sequentially execute the set of instructions it's assigned, "path of execution"
- Every program creates a process and each process is give an initial thread, threads can create more threads
- Threads run independently of each other and scheduling decissions are made at the thread level not the process level
- Threads can run concurrently(each taking a turn on a core) or in parallel(running at the same time on different cores)
- threads maintain their own state to allow for the safe, local and independent execution of their instruction
- OS scheduler is responsible for making sure cores are not idel if there are threads that can be executing. also create illusion that all threads acn execute
- scheduler needs to run Threads with higher priority over lower priority threads. Threads with lower priority can be starved fo execution
- Program Counter: instruction pointer, what instruction is the computer currently on, branches, subroutine calls and returns
    - allows thread to keep track of next instruction to execute, most processors, pc points to the next instrucation 
    - represent the PC value offset from top of the function, next instruction the Thread would have executed inside the example function if the program hadn't panicked
    - represents the PC offset for the instauction inside the example, 57 bytes below the starting instruction fro the function
    - EVM is operating system runtime environment, solidity code must undergo translation from ligh-level human readable to low-level machine readable
    - covert text to hexadecimal values to bytecode, bytecode is generated by a compiler
    - bytecode is processed by the EVM and executed on the network, EVM can be built on top of an FPGA(field Programmable Array) or stack-based CPU
    - EVM is a stack machine(vs register based VM): computer processor or virtual machine in which primary interaction short lived temp values to push down stack
    - stack machine pops values from and pushed values onto a stack, so "+" operation will pop the last two values off the stack add them together then
    - register machine has number of places where values can be stored and oeprations reads writes to those registers, 3 arguments, 2 that represent registers and register to write to
    - LLVM IR(each register is written to exactly once)
    - If IR is entirely in memory this isn't so bad if code is SSA form, wasm has the consept of locals, which are mutable variables that live for lifetime of a function
    - since webassembly blocks cant' take arguments loop counters, reading cariable doesn't involve creating an unnecessary one, 
    - WASM is bytecode, VM instruction set, locals represent both function arguments and local variables
    - machine code must execute opcodes, operation code tells computer what oeperations to perform, opcode are assembly language commands executed by the CPU
    - ABI(applicaiton binary interface): provides standard way to interact iwh tsmark contract over network
    - EVM execute teh compiled code opcodes in the bytecode, if blockchain's state needs to be changed, gas ("unit of computation")
    - Thread State, dictates role the scheduler takes, thread Waiting, Runnable, or Execiting
        - waiting thread is stopped wait on hardware or sid, os (sys calls)sync calls(atomic mutex), blocked on something else
        - runnable thread wants time on a core so it can executeassigned machine instructions
        - executing placed on core and is executing machine instructions
    - CPU bound and IO bound work
        - CPU Bound never creates situation where thread may be placed in waiting state, only calcuations
        - IO BOund can be blocked and waiting, requesting access to resource over network or making system calls(sync events can be io boud as well)
- Context Switching preemptive scheduler, scheduler is unpredictible for threads to chose, priorities help decide
    - must control the synchronization and orchestration of threads if you need determinism
    - physical act of swapping threads on core is called context switch, scheduler pulls an executing thread off a core and replaces it with a runnable thred
    - thread that was selected moves to executing, thread pulled moves to runnable or waiting if it's blocked
    - 12 instructions per/nanosecond, per coreprogram is losing ability to execute large number 
    - don't allow a core to be idle(i.e. if something is IO bound context switch it)
- single processor with single core context:
    - scheduler period, attempt to execute all runnable threads within that period, 1000ms and have 10 threads("paths of execution"), each thread gets 100ms each,
    - context switching becomes untennable at 1ms as you will sepend the majority of the time switching
    - need to set a minimum time slice, "less is more" 
    - Engineer needs to figure out how many thread pools needed
- cache lines: main memory has high latency costprocessors and cores have local cahes keep data close to the hardware threads that need it, each core has a caching architecture
- 64 byte chunk of memory that is exchanged between main memory and caching system, each core hash own copy of any cache line, mutations to memory in multithreaded applications can be bad
- instruction counter based bounding, watchdog timer solution that incuresno noticeable overhead

### Unikernels and MicroKernels
- Cpu can execute certain instruactions only when it is in kernel mode(privilaged context)
- micro: manages all system resources, microkernel user servces and kernel serbvice implementid in different address spces
- !!!!Research seL4!!!
- 

### IDEAS: 
- VDF Timekeeping is done in a stack-based VM...


#### Sources: 
- https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-partX.html
- https://frankdenneman.nl/2016/07/07/numa-deep-dive-part-X-uma-numa/
- https://www.slideshare.net/JohnCutajar/assembly-language-8086-intermediate
- https://www.codeproject.com/Articles/461052/Stack-Based-vs-Register-Based-Virtual-Machine-Arch
- https://lwn.net/Articles/404993/
- https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/
- https://www.youtube.com/watch?v=WDIkqP4JbkE
- https://sel4.systems/About/seL4-whitepaper.pfd
- https://eprint.iacr.org/2020/758.pdf